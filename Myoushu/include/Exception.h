/*
This file is part of the ASD Assist VE Platform.

For the latest info, see http://asd-ve-platform.sourceforge.net/

Copyright (c) 2009 Morné Chamberlain & Stellenbosch University

The ASD Assist VE Platform is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License (with the added restriction
that this work and any derivative works may only be used for non-commercial purposes)
as published by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The ASD Assist VE Platform is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @file Exception.h
 * @author ME Chamberlain
 * @date April 2008
 */

#ifndef EXCEPTION_H
#define EXCEPTION_H

#include <exception>
#include <string>

#include "Platform.h"

namespace Myoushu
{
	/**
	 * This class represents any exceptions that can be generated by the Myoushu engine.
	 */

	class MYOUSHU_API Exception : public std::exception
	{
		public:
			/** Exception types */
			enum ExceptionType
			{
				/** A general exception. */
				E_GENERAL_EXCEPTION,
				/** A std::exception occurred. */
				E_STD_EXCEPTION,
				/** An Ogre::Exception occurred. */
				E_OGRE_EXCEPTION,
				/** A Poco::Exception occurred. */
				E_POCO_EXCEPTION,
				/** An OIS::Exception occurred. */
				E_OIS_EXCEPTION,
				/** A MyGUI::Exception occurred. */
				E_MYGUI_EXCEPTION,
				/** An error occured while executing a LUA script */
				E_LUA_ERROR,
				/** A pointer was NULL when it shouldn't have been. */
				E_NULL_POINTER,
				/** A specified file was not found. */
				E_FILE_NOT_FOUND,
				/** A file that is to be read from or written to is not open. */
				E_FILE_NOT_OPEN,
				/** An invalid enumeration value was used. */
				E_ENUM_TYPE_UNKNOWN,
				/** A templated function or class was implemented with an unexpected type. */
				E_UNEXPECTED_TYPE,
				/** The parameters specified are incorrect or incompatible */
				E_INVALID_PARAMETERS,
				/** An index is out of bounds */
				E_INDEX_OUT_OF_BOUNDS,
				/** If a search through a container/data structure didn't yield the element searched for */
				E_NO_SUCH_ELEMENT,
				/** Error casting between types */
				E_CAST_EXCEPTION,
				/** A memory buffer was too small. */
				E_BUFFER_TOO_SMALL,
				/** A called function or feature is not implemented. */
				E_UNIMPLEMENTED,
				/** A called function or feature has been deprecated. */
				E_DEPRECATED,
				/** An operation refrenced a network host that could not be resolved. */
				E_UNKNOWN_HOST,
				/** An unknown error occurred. */
				E_UNKNOWN_ERROR,
				/** Error while parsing some form of input */
				E_PARSE_ERROR
			};

			/** Nullary Constructor */
			Exception();

			/** Copy Constructor */
			Exception(const Exception& other);

			/** Constructor.
			 * @param type The ExceptionType
			 * @param msg An error message.
			 */
			Exception(ExceptionType type, const std::string& msg);

			/** Destructor */
			~Exception() throw();

			/**
			  * Returns an error message.
			  * @return A string reference containing the error message.
			  */
			const std::string& getMsg() const;

			/**
			  * Gets the exception type.
			  * @return The ExceptionType
			  */
			ExceptionType getExceptionType() const;

			/** Returns an exception message. */
			virtual const char* what() const throw();

			/** 
			 * Assignment operator, set the fields of this instance equal to the fields of the specified
			 * instance.
			 */
			Exception& operator=(const Exception& rhs);

			private:
				ExceptionType exceptionType;
				std::string msg;
	};
	// inlines
	inline const std::string& Exception::getMsg() const
	{
		return msg;
	}

	inline Exception::ExceptionType Exception::getExceptionType() const
	{
		return exceptionType;
	}

	inline const char* Exception::what() const throw()
	{
		return msg.c_str();
	}

	inline Exception& Exception::operator=(const Exception& rhs)
	{
		exceptionType = rhs.getExceptionType();
		msg = rhs.getMsg();

		return (*this);
	}

} // Myoushu

#endif // EXCEPTION_H
